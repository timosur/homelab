name: Deploy GitOps

on:
  push:
    branches: [main]
    paths:
      - 'apps/**'
      - 'infrastructure/**'
      - 'networking/**'
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
  AZURE_KEYVAULT_NAME: ${{ vars.AZURE_KEYVAULT_NAME }}
  CLUSTER_NAME: ${{ vars.CLUSTER_NAME }}
  CLUSTER_RESOURCE_GROUP: ${{ vars.CLUSTER_RESOURCE_GROUP }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.CLUSTER_RESOURCE_GROUP }} \
            --name ${{ env.CLUSTER_NAME }} \
            --overwrite-existing

      - name: Create or update External Secrets namespace
        run: |
          kubectl create namespace external-secrets-system --dry-run=client -o yaml | kubectl apply -f -

      - name: Create or update Azure Service Principal secret
        run: |
          # Create service principal if it doesn't exist
          SP_NAME="external-secrets-sp"
          
          # Check if service principal exists
          SP_EXISTS=$(az ad sp list --display-name "$SP_NAME" --query "[].appId" -o tsv)
          
          if [ -z "$SP_EXISTS" ]; then
            echo "Creating new service principal..."
            SP_DETAILS=$(az ad sp create-for-rbac \
              --name "$SP_NAME" \
              --role "Key Vault Secrets User" \
              --scopes "/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}/providers/Microsoft.KeyVault/vaults/${{ env.AZURE_KEYVAULT_NAME }}" \
              --query '{clientId: appId, clientSecret: password, tenantId: tenant}' \
              -o json)
            
            CLIENT_ID=$(echo "$SP_DETAILS" | jq -r '.clientId')
            CLIENT_SECRET=$(echo "$SP_DETAILS" | jq -r '.clientSecret')
            TENANT_ID=$(echo "$SP_DETAILS" | jq -r '.tenantId')
          else
            echo "Service principal already exists, using existing one..."
            CLIENT_ID="$SP_EXISTS"
            # For existing SP, we'll need to create a new secret or use stored one
            # This is a limitation - you might want to store the secret in GitHub Secrets
            echo "Warning: Using existing SP, ensure CLIENT_SECRET is available in GitHub Secrets"
            CLIENT_SECRET="${{ secrets.AZURE_SP_CLIENT_SECRET }}"
            TENANT_ID="${{ secrets.AZURE_TENANT_ID }}"
          fi

          # Grant Key Vault permissions if needed
          az keyvault set-policy \
            --name "${{ env.AZURE_KEYVAULT_NAME }}" \
            --spn "$CLIENT_ID" \
            --secret-permissions get list

          # Create or update the Kubernetes secret
          kubectl create secret generic azure-secret \
            --namespace=external-secrets-system \
            --from-literal=ClientID="$CLIENT_ID" \
            --from-literal=ClientSecret="$CLIENT_SECRET" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Update Azure Key Vault URL in ClusterSecretStore
        run: |
          # Update the kustomization with actual Key Vault URL
          VAULT_URL="https://${{ env.AZURE_KEYVAULT_NAME }}.vault.azure.net/"
          TENANT_ID="${{ secrets.AZURE_TENANT_ID }}"
          
          # Create a temporary patch file
          cat > /tmp/azure-secretstore-patch.yaml << EOF
          apiVersion: external-secrets.io/v1beta1
          kind: ClusterSecretStore
          metadata:
            name: azure-keyvault-store
          spec:
            provider:
              azurekv:
                vaultUrl: "$VAULT_URL"
                authSecretRef:
                  clientId:
                    name: azure-secret
                    key: ClientID
                    namespace: external-secrets-system
                  clientSecret:
                    name: azure-secret
                    key: ClientSecret
                    namespace: external-secrets-system
                tenantId: "$TENANT_ID"
          EOF
          
          # Apply the patch
          kubectl apply -f /tmp/azure-secretstore-patch.yaml

      - name: Create PostgreSQL secrets in Azure Key Vault
        run: |
          # Generate strong password if it doesn't exist
          if ! az keyvault secret show --vault-name "${{ env.AZURE_KEYVAULT_NAME }}" --name "mealie-postgres-password" >/dev/null 2>&1; then
            POSTGRES_PASSWORD=$(openssl rand -base64 32)
            
            az keyvault secret set \
              --vault-name "${{ env.AZURE_KEYVAULT_NAME }}" \
              --name "mealie-postgres-username" \
              --value "mealie"
            
            az keyvault secret set \
              --vault-name "${{ env.AZURE_KEYVAULT_NAME }}" \
              --name "mealie-postgres-password" \
              --value "$POSTGRES_PASSWORD"
            
            echo "PostgreSQL secrets created in Key Vault"
          else
            echo "PostgreSQL secrets already exist in Key Vault"
          fi

      - name: Wait for External Secrets Operator
        run: |
          echo "Waiting for External Secrets Operator to be ready..."
          kubectl wait --for=condition=available deployment/external-secrets \
            --namespace=external-secrets-system \
            --timeout=300s || true

      - name: Verify External Secrets
        run: |
          echo "Checking ExternalSecret status..."
          kubectl get externalsecrets -A || true
          kubectl get secrets -n mealie || true
